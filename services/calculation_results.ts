/**
 * CalculationResults API Service
 * Generated by API generator
 */

import { storage } from './storage';
import { db, authReady, getCurrentFirebaseUser } from './firebase';
import { collection, getDocs, addDoc, query, where, orderBy } from 'firebase/firestore';
import type {
  CalculationResult,
  CalculationResultResponse,
  CalculationResultsResponse,
  CreateCalculationResultInput,
} from '../types/calculation_results';

const KEY = 'calculation_results';

class CalculationResultsService {
  async getAll(): Promise<CalculationResultsResponse> {
    // Wait for auth initialization
    await authReady;
    const currentUser = await getCurrentFirebaseUser();
    const uid = currentUser?.uid || (await storage.get('uid'));

    // If user is signed in, prefer Firestore-backed results
    if (uid) {
      try {
        const col = collection(db, 'calculation_results');
        const q = query(col, where('userId', '==', uid), orderBy('performedAt', 'desc'));
        const snap = await getDocs(q);
        const items: CalculationResult[] = snap.docs.map(d => ({ id: d.id, ...(d.data() as any) }));
        // Also include any local results that haven't been migrated
        const raw = await storage.get(KEY);
        let local: CalculationResult[] = [];
        if (raw) {
          try {
            local = JSON.parse(raw) as CalculationResult[];
          } catch (e) {
            local = [];
          }
        }
        const notMigrated = local.filter(r => !r.migrated);
        return [...notMigrated, ...items] as CalculationResultsResponse;
      } catch (err) {
        console.warn('Failed to read Firestore results, falling back to local', err);
      }
    }

    const raw = await storage.get(KEY);
    if (!raw) return [] as CalculationResultsResponse;
    try {
      const items = JSON.parse(raw) as CalculationResult[];
      return items;
    } catch (e) {
      return [] as CalculationResultsResponse;
    }
  }

  async getById(id: string): Promise<CalculationResultResponse> {
    const all = await this.getAll();
    const found = all.find(r => String((r as any).id) === String(id));
    if (!found) throw new Error('Calculation result not found');
    return found as CalculationResultResponse;
  }

  async create(data: CreateCalculationResultInput): Promise<CalculationResultResponse> {
    await authReady;
    const currentUser = await getCurrentFirebaseUser();
    const uid = currentUser?.uid || (await storage.get('uid')) || null;

    const payload: any = {
      ...data,
      userId: uid,
      performedAt: new Date().toISOString(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    // If user is authenticated, save to Firestore and also keep a local copy
    if (uid) {
      try {
        const ref = await addDoc(collection(db, 'calculation_results'), payload as any);
        const saved = { id: ref.id, ...payload } as CalculationResultResponse;
        // Also persist a local copy marked as migrated
        const raw = await storage.get(KEY);
        let local: CalculationResult[] = [];
        if (raw) {
          try { local = JSON.parse(raw) as CalculationResult[]; } catch (e) { local = []; }
        }
        local.unshift({ ...saved, migrated: true } as any);
        await storage.set(KEY, JSON.stringify(local));
        return saved;
      } catch (err) {
        console.warn('Failed to write to Firestore, saving locally', err);
      }
    }

    // Fallback: save locally
    const all = await this.getAll();
    const id = Date.now().toString();
    const localPayload: any = {
      id,
      ...payload,
      migrated: false,
    };
    all.unshift(localPayload);
    await storage.set(KEY, JSON.stringify(all));
    return localPayload as CalculationResultResponse;
  }

  async migrateLocalToFirestore(): Promise<void> {
    await authReady;
    const currentUser = await getCurrentFirebaseUser();
    const uid = currentUser?.uid;
    if (!uid) return;

    const raw = await storage.get(KEY);
    if (!raw) return;
    let local: CalculationResult[] = [];
    try { local = JSON.parse(raw) as CalculationResult[]; } catch (e) { local = []; }
    const toMigrate = local.filter(r => !r.migrated);
    if (toMigrate.length === 0) return;

    const migratedIds: string[] = [];
    for (const item of toMigrate) {
      try {
        const payload = { ...item, userId: uid, performedAt: item.performedAt || new Date().toISOString() };
        const ref = await addDoc(collection(db, 'calculation_results'), payload as any);
        migratedIds.push(item.id as string);
      } catch (err) {
        console.warn('Failed to migrate item', item.id, err);
      }
    }

    // Remove migrated items from local store
    const remaining = local.filter(r => !migratedIds.includes(String(r.id)));
    await storage.set(KEY, JSON.stringify(remaining));
  }
}

export const calculationResultsService = new CalculationResultsService();
