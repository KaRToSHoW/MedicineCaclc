# Архитектурные изменения: Калькуляторы на фронтенде

## Обзор изменений

Приложение Medical Calculator было переработано для перемещения всей логики калькуляторов на фронтенд. Бэкенд теперь используется только для хранения истории расчетов.

## Основные изменения

### 1. Удалена таблица Calculator из бэкенда

**Удалены файлы:**
- `api/app/api/v1/calculators.py` - API эндпоинты для калькуляторов
- `api/seed_data.py` - скрипты сидирования калькуляторов
- `api/seed_cockcroft_gault.py` - скрипт сидирования Cockcroft-Gault
- `types/calculators.ts` - типы для калькуляторов с бэкенда
- `services/calculators.ts` - сервисы для работы с API калькуляторов
- `stores/calculatorsStore.ts` - Zustand store для калькуляторов

**Обновлены модели:**
```python
# api/app/models/__init__.py
class CalculationResult(Base):
    """Calculation result model"""
    __tablename__ = "calculation_results"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    calculator_name = Column(String(255), nullable=False, index=True)  # Вместо calculator_id
    calculator_name_ru = Column(String(255))
    input_data = Column(JSON, nullable=False)
    result_value = Column(Float, nullable=False)
    interpretation = Column(Text)
    performed_at = Column(DateTime(timezone=True), server_default=func.now())
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="calculation_results")
```

### 2. Созданы определения калькуляторов на фронтенде

**Новые файлы:**
- `lib/calculators/cockcroftGault.ts` - определение калькулятора Cockcroft-Gault с формулой и интерпретацией
- `lib/calculators/index.ts` - реестр всех калькуляторов

**Структура калькулятора:**
```typescript
export interface Calculator {
  name: string;
  nameRu?: string;
  description?: string;
  descriptionRu?: string;
  category: string;
  categoryRu?: string;
  inputFields: InputField[];
  interpretationRules?: InterpretationRule[];
  calculate: (inputData: Record<string, any>) => number;  // Функция расчета
  interpret?: (resultValue: number) => { text: string; textRu?: string; severity?: string };
}
```

**Пример калькулятора:**
```typescript
export const cockcroftGaultCalculator: Calculator = {
  name: 'Cockcroft-Gault Creatinine Clearance',
  nameRu: 'Клиренс креатинина (Cockcroft-Gault)',
  // ... поля ввода, правила интерпретации
  
  calculate: (inputData: Record<string, any>): number => {
    const age = parseFloat(inputData.age);
    const weight = parseFloat(inputData.weight);
    const creatinine = parseFloat(inputData.creatinine);
    const sexFactor = parseFloat(inputData.sex_factor || '1.0');
    
    // Формула Cockcroft-Gault
    const result = ((140 - age) * weight * sexFactor) / (72 * creatinine);
    return Math.round(result * 100) / 100;
  },
  
  interpret: (resultValue: number) => {
    // Логика интерпретации на основе правил
    // Возвращает { text, textRu, severity }
  }
};
```

### 3. Обновлены API эндпоинты calculation_results

**Изменения в `api/app/api/v1/calculation_results.py`:**
- Удалены функции `evaluate_formula()` и `interpret_result()`
- Эндпоинт POST теперь принимает готовый результат расчета от фронтенда:

```python
class CalculationResultCreate(BaseModel):
    calculator_name: str
    calculator_name_ru: Optional[str] = None
    input_data: Dict[str, Any]
    result_value: float  # Уже рассчитано на фронте
    interpretation: Optional[str] = None  # Уже интерпретировано на фронте

@router.post("/calculation_results", response_model=CalculationResultResponse)
async def create_calculation_result(
    calculation_data: CalculationResultCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create new calculation result"""
    # Сохранение результата (расчет уже выполнен на фронтенде)
    new_result = CalculationResult(
        user_id=current_user.id,
        calculator_name=calculation_data.calculator_name,
        calculator_name_ru=calculation_data.calculator_name_ru,
        input_data=calculation_data.input_data,
        result_value=calculation_data.result_value,
        interpretation=calculation_data.interpretation
    )
    db.add(new_result)
    await db.commit()
    await db.refresh(new_result)
    return new_result
```

### 4. Обновлен экран калькулятора

**Изменения в `app/cockcroft-gault.tsx`:**
```typescript
import { cockcroftGaultCalculator } from '@/lib/calculators/cockcroftGault';

const handleCalculate = async () => {
  if (!validateForm()) return;
  
  try {
    // Подготовка данных
    const inputData: Record<string, any> = {};
    calculator.inputFields.forEach((field: InputField) => {
      if (field.type === 'number') {
        inputData[field.name] = parseFloat(formData[field.name]);
      } else {
        inputData[field.name] = formData[field.name];
      }
    });
    inputData['sex_factor'] = formData['sex_factor'];
    
    // Расчет на фронтенде
    const resultValue = calculator.calculate(inputData);
    
    // Интерпретация на фронтенде
    const interpretationResult = calculator.interpret 
      ? calculator.interpret(resultValue) 
      : { text: 'Result calculated', textRu: 'Результат рассчитан', severity: 'normal' };
    
    // Сохранение в историю на бэкенде
    await createResult({
      calculatorName: calculator.name,
      calculatorNameRu: calculator.nameRu,
      inputData,
      resultValue,
      interpretation: interpretationResult.textRu || interpretationResult.text
    });
    
    setResult({
      value: resultValue,
      interpretation: interpretationResult.textRu || interpretationResult.text,
      severity: interpretationResult.severity
    });
  } catch (error: any) {
    console.error('Calculation error:', error);
    alert('Ошибка при расчете. Попробуйте снова.');
  }
};
```

## Преимущества новой архитектуры

1. **Производительность**: Расчеты выполняются мгновенно на клиенте, без сетевых запросов
2. **Оффлайн работа**: Калькуляторы работают без подключения к интернету
3. **Простота**: Вся логика калькулятора в одном месте на фронтенде
4. **Масштабируемость**: Легко добавлять новые калькуляторы без изменений в бэкенде
5. **Безопасность**: Бэкенд хранит только результаты, не выполняет расчеты с пользовательскими данными

## Миграция данных

Создан скрипт миграции `api/migrate.py`:
```bash
python3 api/migrate.py
```

Скрипт выполняет:
1. Удаление таблицы `calculators`
2. Пересоздание таблицы `calculation_results` с новой структурой
3. Обновление `usage_statistics` (удаление `calculator_id`, добавление `calculator_name`)

## Как добавить новый калькулятор

1. Создать файл в `lib/calculators/myCalculator.ts`:
```typescript
export const myCalculator: Calculator = {
  name: 'My Calculator',
  nameRu: 'Мой калькулятор',
  // ... определить inputFields, interpretationRules
  
  calculate: (inputData) => {
    // Логика расчета
    return result;
  },
  
  interpret: (resultValue) => {
    // Логика интерпретации
    return { text: '...', textRu: '...', severity: 'normal' };
  }
};
```

2. Добавить в `lib/calculators/index.ts`:
```typescript
import { myCalculator } from './myCalculator';

export const calculators: Calculator[] = [
  cockcroftGaultCalculator,
  myCalculator  // Добавить сюда
];
```

3. Создать экран калькулятора `app/my-calculator.tsx` (можно скопировать `cockcroft-gault.tsx`)

4. Добавить ссылку на главной странице `app/index.tsx`

## Тестирование

Все тесты пройдены:
```bash
npm test
# Test Suites: 3 passed, 3 total
# Tests: 8 passed, 8 total
```

Бэкенд работает:
```bash
curl http://localhost:8000/api/v1/health
# {"status":"healthy"}
```

Фронтенд доступен:
```bash
curl http://localhost:3000
# HTML с приложением Expo
```
